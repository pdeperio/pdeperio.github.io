{%- assign _id = include.id | default: "vr360-" | append: include.src | replace: "/", "-" | replace: ".", "-" -%}
<div class="vr-360-wrapper" id="{{ _id }}" style="max-width:100%; position:relative;">
  <style>
    .vr-360-wrapper canvas.a-canvas { touch-action: none !important; pointer-events: auto !important; }
    .vr-360-wrapper .a-canvas { cursor: grab; }
    .vr-360-wrapper .a-canvas:active { cursor: grabbing; }
    /* Stop parents from hijacking scroll/drag */
    .vr-360-wrapper { overscroll-behavior: contain; }
  </style>

  <a-scene
    embedded
    vr-mode-ui="enabled: true"
    renderer="antialias: true"
    style="width: 100%; height: {{ include.height | default: '60vh' }};"
  >
    <a-assets>
      <img id="{{ _id }}-asset" src="{{ include.src | relative_url }}" crossorigin="anonymous">
    </a-assets>

    <a-sky id="{{ _id }}-sky" src="#{{ _id }}-asset" rotation="0 -90 0"></a-sky>

    <!-- Camera rig with explicit look-controls -->
    <a-entity id="{{ _id }}-cam"
      camera
      look-controls="reverseMouseDrag: true; mouseEnabled: true; touchEnabled: true; pointerLockEnabled: false"
      position="0 0 0">
    </a-entity>
  </a-scene>

  {%- if include.caption -%}
  <p style="margin:.5rem 0 0; font-size:.9rem; color:#666">{{ include.caption }}</p>
  {%- endif -%}

  <script>
  (function(){
    var root  = document.getElementById('{{ _id }}');
    var scene = root.querySelector('a-scene');
    var camEl = document.getElementById('{{ _id }}-cam');

    function clamp(v,a,b){ return Math.min(b, Math.max(a, v)); }

    function normalizeWheelDelta(e){
      // Cross-browser wheel (pixels vs lines vs legacy)
      var dy = ('deltaY' in e) ? e.deltaY : (e.wheelDeltaY ? -e.wheelDeltaY : (e.wheelDelta ? -e.wheelDelta : 0));
      if (e.deltaMode === 1) dy *= 15;  // lines -> pixels (Firefox)
      return dy;
    }

    function attachWheelZoom(target, cam, fovMin, fovMax){
      if (!target) return;
      target.addEventListener('wheel', function(e){
        // Keep the event here (themes sometimes stop it higher up)
        e.preventDefault(); e.stopPropagation();
        var dy = normalizeWheelDelta(e);
        var step = (dy > 0 ? +2 : -2);
        cam.fov = clamp(cam.fov + step, fovMin, fovMax);
        cam.updateProjectionMatrix();
      }, { passive: false });
    }

    scene.addEventListener('loaded', function(){
      // Make sure look-controls is actually active and reversed
      if (!camEl.components['look-controls']) {
        camEl.setAttribute('look-controls', 'enabled: true; reverseMouseDrag: true; mouseEnabled: true; touchEnabled: true; pointerLockEnabled: false');
      } else {
        camEl.components['look-controls'].reverseMouseDrag = true;
        camEl.components['look-controls'].pointerLockEnabled = false;
        camEl.components['look-controls'].mouseEnabled = true;
        camEl.components['look-controls'].touchEnabled = true;
      }

      var cam = scene.camera; // THREE.PerspectiveCamera
      if (!cam) return;

      var fovMin = 30, fovMax = 100;

      // Attach wheel zoom to multiple layers to beat theme interceptors
      attachWheelZoom(scene.canvas, cam, fovMin, fovMax);                  // primary
      attachWheelZoom(root, cam, fovMin, fovMax);                          // wrapper
      attachWheelZoom(scene.renderer && scene.renderer.domElement, cam, fovMin, fovMax); // fallback
      attachWheelZoom(window, cam, fovMin, fovMax);                        // ultimate fallback

      // Pinch zoom
      var touches = [];
      root.addEventListener('touchstart', function(e){
        if (e.touches.length >= 2) touches = [e.touches[0], e.touches[1]];
      }, { passive: true });

      root.addEventListener('touchmove', function(e){
        if (e.touches.length >= 2 && touches.length === 2) {
          var t0 = e.touches[0], t1 = e.touches[1];
          var prev = Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
          var curr = Math.hypot(t0.clientX - t1.clientX, t0.clientY - t1.clientY);
          var delta = prev - curr; // pinch-in => positive
          var step = (delta > 0 ? +1.5 : -1.5);
          cam.fov = clamp(cam.fov + step, fovMin, fovMax);
          cam.updateProjectionMatrix();
          touches = [t0, t1];
          e.preventDefault();
        }
      }, { passive: false });
    });

    // Safety: ensure drag is reversed even if A-Frame re-inits (rare)
    scene.addEventListener('componentinitialized', function(evt){
      if (evt.detail && evt.detail.name === 'look-controls' && evt.target === camEl){
        camEl.setAttribute('look-controls', 'reverseMouseDrag: true; pointerLockEnabled: false; mouseEnabled: true; touchEnabled: true');
      }
    });
  })();
  </script>

  <noscript><img src="{{ include.src | relative_url }}" alt="360 panorama" style="width:100%;height:auto;"></noscript>
</div>
