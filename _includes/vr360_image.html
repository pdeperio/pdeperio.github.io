{%- comment -%}
Drop-in 360Â° image viewer using Pannellum, preserving the vr360_image.html API.
Supports: wheel zoom, pinch zoom, drag (with optional inversion), fullscreen.
Params:
  - src (required): path to equirectangular JPG/PNG
  - height (optional): CSS height (default 60vh)
  - caption (optional)
  - invert_drag (optional): "true" to reverse drag direction
  - hfov, min_hfov, max_hfov, yaw, pitch (optionals)
{%- endcomment -%}

{%- assign _id = include.id | default: "pano-" | append: include.src | replace: "/", "-" | replace: ".", "-" -%}

<!-- Pannellum (once per page is fine; duplicates are ignored by the browser cache) -->
<link rel="stylesheet" href="https://unpkg.com/pannellum@2.5.6/build/pannellum.css">
<script src="https://unpkg.com/pannellum@2.5.6/build/pannellum.js"></script>

<div id="{{ _id }}" class="pano360"
     style="width:100%;height:{{ include.height | default: '60vh' }};background:#000;border-radius:8px;overflow:hidden;overscroll-behavior:contain;touch-action:none">
</div>
{%- if include.caption -%}
<p style="margin:.5rem 0 0;font-size:.9rem;color:#666">{{ include.caption }}</p>
{%- endif -%}

<script>
(function(){
  var el = document.getElementById('{{ _id }}');
  if (!el || !window.pannellum) return;

  var invert = "{{ include.invert_drag | default: 'false' }}" === "true";
  var viewer = pannellum.viewer(el, {
    type: "equirectangular",
    panorama: "{{ include.src | relative_url }}",
    autoLoad: true,
    showZoomCtrl: true,
    showFullscreenCtrl: true,
    keyboardZoom: true,
    draggable: true,
    mouseZoom: true,
    hfov: {{ include.hfov | default: 100 }},
    minHfov: {{ include.min_hfov | default: 40 }},
    maxHfov: {{ include.max_hfov | default: 120 }},
    yaw: {{ include.yaw | default: 0 }},
    pitch: {{ include.pitch | default: 0 }}
  });

  // Invert drag direction if requested (applies to mouse/touch)
  if (invert) {
    // We wrap viewer's drag handling by translating deltas.
    // Listen on container and feed inverted movements via yaw/pitch setters.
    var dragging = false, start = null, base = null;
    // Disable internal drag so we can control direction.
    el.classList.add('pano-custom-drag');
    viewer.setOption('draggable', false);

    function clamp(v, a, b){ return Math.min(b, Math.max(a, v)); }

    function onDown(e){
      dragging = true;
      var pt = ('touches' in e) ? e.touches[0] : e;
      start = {x: pt.clientX, y: pt.clientY};
      base = {yaw: viewer.getYaw(), pitch: viewer.getPitch()};
      el.style.cursor = 'grabbing';
      e.preventDefault();
    }
    function onMove(e){
      if (!dragging) return;
      var pt = ('touches' in e) ? e.touches[0] : e;
      var dx = pt.clientX - start.x;
      var dy = pt.clientY - start.y;
      var scale = 0.1; // sensitivity
      // Inverted: move left -> yaw right, move up -> pitch down
      viewer.setYaw(base.yaw + dx * scale);
      viewer.setPitch(clamp(base.pitch - dy * scale, -85, 85));
      e.preventDefault();
    }
    function onUp(){ dragging = false; el.style.cursor = ''; }

    el.addEventListener('mousedown', onDown, {passive:false});
    window.addEventListener('mousemove', onMove, {passive:false});
    window.addEventListener('mouseup', onUp, {passive:true});
    el.addEventListener('touchstart', onDown, {passive:false});
    el.addEventListener('touchmove', onMove, {passive:false});
    el.addEventListener('touchend', onUp, {passive:true});
  }

  // Make sure wheel/pinch always work even if theme has passive listeners
  function wheelHandler(e){
    // Normalize deltas; positive => zoom out by increasing hfov
    var dy = ('deltaY' in e) ? e.deltaY : (e.wheelDelta ? -e.wheelDelta : 0);
    if (e.deltaMode === 1) dy *= 15; // lines -> px
    var step = (dy > 0 ? +3 : -3);
    var next = viewer.getHfov() + step;
    var minH = viewer.getConfig().minHfov || 40, maxH = viewer.getConfig().maxHfov || 120;
    viewer.setHfov(Math.max(minH, Math.min(maxH, next)));
    e.preventDefault(); e.stopPropagation();
  }
  el.addEventListener('wheel', wheelHandler, {passive:false});
  // Also attach to the internal canvas once it exists.
  var tryCanvas = setInterval(function(){
    var canvas = el.querySelector('canvas');
    if (canvas){
      canvas.addEventListener('wheel', wheelHandler, {passive:false});
      clearInterval(tryCanvas);
    }
  }, 100);
})();
</script>

<noscript><img src="{{ include.src | relative_url }}" alt="360 panorama" style="width:100%;height:auto;"></noscript>
